-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell bindings for CacBDD
--   
--   Haskell bindings for CacBDD, a Binary Decision Diagram (BDD) package
--   with dynamic cache management. Original C++ code from
--   <a>http://kailesu.net/CacBDD</a> and a C wrapper are included.
@package HasCacBDD
@version 0.1.0.3


-- | Haskell bindings for CacBDD, a BDD Package with Dynamic Cache
--   Management.
module Data.HasCacBDD

-- | The CacBDD datatype has no structure because from our perspective BDDs
--   are just pointers.
data Bdd

-- | An assignment of boolean values to variables/integers.
type Assignment = [(Int, Bool)]

-- | True constant
top :: Bdd

-- | False constant
bot :: Bdd

-- | Variable, indexed by any integer from 0 to 1.000.000 FIXME: Segfaults
--   if n is negative or out of range. Can we add a safety check without
--   affecting performance?
var :: Int -> Bdd

-- | Negation
neg :: Bdd -> Bdd

-- | Conjunction
con :: Bdd -> Bdd -> Bdd

-- | Disjunction
dis :: Bdd -> Bdd -> Bdd

-- | Implication, via disjunction and negation. Somehow this is faster than
--   calling LessEqual?
imp :: Bdd -> Bdd -> Bdd

-- | Equivalence aka Biimplication
equ :: Bdd -> Bdd -> Bdd

-- | Exclusive Or
xor :: Bdd -> Bdd -> Bdd

-- | Big Conjunction
conSet :: [Bdd] -> Bdd

-- | Big Disjunction
disSet :: [Bdd] -> Bdd

-- | Big Xor
xorSet :: [Bdd] -> Bdd

-- | Existential Quantification
exists :: Int -> Bdd -> Bdd

-- | Universal Quantification
forall :: Int -> Bdd -> Bdd

-- | Big Universal Quantification
forallSet :: [Int] -> Bdd -> Bdd

-- | Big Existential Quantification
existsSet :: [Int] -> Bdd -> Bdd

-- | Restrict a single variable to a given value
restrict :: Bdd -> (Int, Bool) -> Bdd

-- | Restrict with a (partial) assignment
restrictSet :: Bdd -> Assignment -> Bdd

-- | Restrict with a law. Note that the law is the second parameter!
restrictLaw :: Bdd -> Bdd -> Bdd

-- | If ... then ... else ...
ifthenelse :: Bdd -> Bdd -> Bdd -> Bdd

-- | Greatest fixpoint for a given operator.
gfp :: (Bdd -> Bdd) -> Bdd

-- | Relabel variables according to the given mapping. Note that the
--   mapping list must be sorted!
relabel :: [(Int, Int)] -> Bdd -> Bdd

-- | Relabel variables according to the given function.
relabelFun :: (Int -> Int) -> Bdd -> Bdd

-- | Substitute a BDD for a given variable in another BDD.
substit :: Int -> Bdd -> Bdd -> Bdd

-- | Simultaneous substitution of BDDs for variables. Note that this is not
--   the same as folding <a>substit</a>.
substitSimul :: [(Int, Bdd)] -> Bdd -> Bdd

-- | Evaluate a BDD given an assignment. Returns Nothing if the assignment
--   does not cover allVarsOf b.
evaluate :: Bdd -> Assignment -> Maybe Bool

-- | Evaluate a BDD given a total assignment function.
evaluateFun :: Bdd -> (Int -> Bool) -> Bool

-- | Get all satisfying assignments. These will be partial, i.e. only
--   contain (a subset of) the variables that actually occur in the BDD.
allSats :: Bdd -> [Assignment]

-- | Get all complete assignments, given a set of all variables. In
--   particular this will include variables not in the BDD.
allSatsWith :: [Int] -> Bdd -> [Assignment]

-- | Given a set of all variables, get the number of satisfying
--   assignments. Note that allvars must be nub'd and sorted.
satCountWith :: [Int] -> Bdd -> Int

-- | Get the lexicographically smallest satisfying assignment, if there is
--   any.
anySat :: Bdd -> Maybe Assignment

-- | Given a set of all variables, get the lexicographically smallest
--   complete satisfying assignment, if there is any.
anySatWith :: [Int] -> Bdd -> Maybe Assignment

-- | The first variable of a given BDD, if there is one.
firstVarOf :: Bdd -> Maybe Int

-- | The maximum variable of a given BDD, if there is one.
maxVarOf :: Bdd -> Maybe Int

-- | All variables in a given BDD, *not* sorted, lazy.
allVarsOf :: Bdd -> [Int]

-- | All variables in a given BDD, sorted, *not* lazy.
allVarsOfSorted :: Bdd -> [Int]

-- | Then-branch of a given BDD, setting firstVarOf to True.
thenOf :: Bdd -> Bdd

-- | Else-branch of a given BDD, setting firstVarOf to False.
elseOf :: Bdd -> Bdd

-- | List all the sub-BDDs of a given BDD.
subsOf :: Bdd -> [Bdd]

-- | Size of the BDD, should be the number of non-terminal nodes.
sizeOf :: Bdd -> Int

-- | A simple tree definition to show BDDs as text.
data BddTree
Bot :: BddTree
Top :: BddTree
Var :: Int -> BddTree -> BddTree -> BddTree

-- | Convert a BDD to a tree.
unravel :: Bdd -> BddTree

-- | Convert a tree to a BDD.
ravel :: BddTree -> Bdd

-- | The maximum number of variables
maximumvar :: Int

-- | Show internal statistics.
showInfo :: IO ()
instance GHC.Show.Show Data.HasCacBDD.BddTree
instance GHC.Read.Read Data.HasCacBDD.BddTree
instance GHC.Classes.Eq Data.HasCacBDD.BddTree
instance GHC.Classes.Eq Data.HasCacBDD.Bdd
instance GHC.Show.Show Data.HasCacBDD.Bdd
instance GHC.Read.Read Data.HasCacBDD.Bdd
instance Test.QuickCheck.Arbitrary.Arbitrary Data.HasCacBDD.Bdd


-- | Very simple visualisation of BDDs using <i>dot</i>.
module Data.HasCacBDD.Visuals

-- | Generate a string which describes the BDD in the dot language.
genGraph :: Bdd -> String

-- | Given a function to show variables, generate a string which describes
--   the BDD in the dot language.
genGraphWith :: (Int -> String) -> Bdd -> String

-- | Display the graph of a BDD with dot.
showGraph :: Bdd -> IO ()

-- | Generate SVG of a BDD with dot.
svgGraph :: Bdd -> IO String
