-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/RamonMeffert/epistemic-group-gossip#readme</a>
@package epistemic-group-gossip
@version 0.1.0.0


module PrintableBdd

-- | Printable data wrapper for the <a>Bdd</a> record.
data Bdd

-- | The binary decision diagram, as a <a>Bdd</a> type.
bdd :: Bdd -> Bdd

-- | The formula represented as a unicode string for direct printing.
str :: Bdd -> String

-- | The formula represented as a string, formatted in LaTeX.
tex :: Bdd -> String

-- | An assignment is a valuation for a set of variables, i.e. a valuation
--   as to whether a variable is true or false.
type Assignment = [(Int, Bool)]

-- | The printable BDD can label their variables, instead of using
--   integers. A VarLabeller type is a function that encodes a variable
--   integer to its corresponding name.
type VarLabeller = (Int -> String)

-- | Encode a labelled integer as a BDD variable. Note that the first
--   labeller is for text, the second for LaTeX. The variable is indexed by
--   any integer from 0 to 1.000.000.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = varl slabel tlabel 0
--   
--   &gt;&gt;&gt; foo
--   var0
--   
--   &gt;&gt;&gt; tex foo
--   p_0
--   </pre>
varl :: VarLabeller -> VarLabeller -> Int -> Bdd

-- | Encode an unlabelled integer as a BDD variable. The variable is
--   indexed by any integer from 0 to 1.000.000.
var :: Int -> Bdd

-- | True constant.
--   
--   <pre>
--   &gt;&gt;&gt; top
--   ⊤
--   </pre>
top :: Bdd

-- | False constant.
--   
--   <pre>
--   &gt;&gt;&gt; bot
--   ⊥
--   </pre>
bot :: Bdd

-- | Negation.
--   
--   <pre>
--   &gt;&gt;&gt; neg foo
--   ¬(foo)
--   </pre>
neg :: Bdd -> Bdd

-- | Conjunction.
--   
--   <pre>
--   &gt;&gt;&gt; foo `con` bar
--   (foo ∧ bar)
--   </pre>
con :: Bdd -> Bdd -> Bdd

-- | Disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; foo `dis` bar
--   (foo ∨ bar)
--   </pre>
dis :: Bdd -> Bdd -> Bdd

-- | Logical implication.
--   
--   <pre>
--   &gt;&gt;&gt; foo `imp` bar
--   (foo ⟶ bar)
--   </pre>
imp :: Bdd -> Bdd -> Bdd

-- | Logical bi-implication or equivalence.
--   
--   <pre>
--   &gt;&gt;&gt; foo `equ` bar
--   (foo ⟷ bar)
--   </pre>
equ :: Bdd -> Bdd -> Bdd

-- | Exlusive or.
--   
--   <pre>
--   &gt;&gt;&gt; foo `xor` bar
--   (foo ⊻ bar)
--   </pre>
xor :: Bdd -> Bdd -> Bdd

-- | Big (setwise) conjunction.
--   
--   <pre>
--   &gt;&gt;&gt; conSet [foo, bar, baz]
--   (foo ∧ bar ∧ baz)
--   </pre>
conSet :: [Bdd] -> Bdd

-- | Big (setwise) disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; disSet [foo, bar, baz]
--   (foo ∨ bar ∨ baz)
--   </pre>
disSet :: [Bdd] -> Bdd

-- | Big (setwise) exclusive disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; xorSet [foo, bar, baz]
--   (foo ⊻ bar ⊻ baz)
--   </pre>
xorSet :: [Bdd] -> Bdd

-- | Labelled binary universal quantification. Note that the first
--   VarLabeller works for direct printing and the VarLabeller is for
--   latex.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = foralll slabel tlabel 0 $ varl slabel tlabel 0 `imp` varl slabel tlabel 1
--   
--   &gt;&gt;&gt; foo
--   ∀var0(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\forall p_0 (p_0 \\rightarrow p_1)
--   </pre>
foralll :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd

-- | Unlabelled binary universal quantification.
--   
--   <pre>
--   &gt;&gt;&gt; forall 0 foo
--   ∀0(foo)
--   </pre>
forall :: Int -> Bdd -> Bdd

-- | Labelled binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = existsl slabel tlabel 0 $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∃var0(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\exists (p_0 \\rightarrow p_1) 
--   </pre>
existsl :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd

-- | Unlabelled binary existential quantification
--   
--   <pre>
--   &gt;&gt;&gt; exists 0 foo
--   ∃0(foo)
--   </pre>
exists :: Int -> Bdd -> Bdd

-- | Labelled big binary universal quanficition.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = forallSetl slabel tlabel [0, 1] $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∀{var0, var1}(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\forall \\left{ p_0, p_1 \\right} (p_0 \\rightarrow p_1)
--   </pre>
forallSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd

-- | Unlabelled big binary universal quantification.
--   
--   <pre>
--   &gt;&gt;&gt; forallSet [0,1,2] foo
--   ∀{0,1,2}(foo)
--   </pre>
forallSet :: [Int] -> Bdd -> Bdd

-- | Labelled big binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = existsSetl slabel tlabel [0, 1] $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∃{var0, var1}(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\exists \\left{ p_0, p_1 \\right} (p_0 \\rightarrow p_1)
--   </pre>
existsSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd

-- | Unlabelled big binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; existsSet [0,1,2] foo
--   ∃{0,1,2}(foo)
--   </pre>
existsSet :: [Int] -> Bdd -> Bdd

-- | Labelled substitution.
--   
--   <pre>
--   &gt;&gt;&gt; label n = "var" ++ n
--   
--   &gt;&gt;&gt; subsitl label 0 top foo
--   [var0\⊤](foo)
--   </pre>
substitl :: VarLabeller -> Int -> Bdd -> Bdd -> Bdd

-- | Unlabelled substitution.
--   
--   <pre>
--   &gt;&gt;&gt; substit 0 top foo
--   [0\⊤]foo
--   </pre>
substit :: Int -> Bdd -> Bdd -> Bdd

-- | Returns all variables (without labels) that occur within the given
--   BDD.
--   
--   <pre>
--   &gt;&gt;&gt; allVarsOf (var 0 `imp` (var 1 `dis` var 2))
--   [0,1,2]
--   </pre>
allVarsOf :: Bdd -> [Int]

-- | Evaluate a BDD, given an assignment. Returns Nothing if the assignment
--   doesn't contain all variables of the BDD.
--   
--   <pre>
--   &gt;&gt;&gt; evaluate (var 0 `imp` var 1) [(0, True), (1, False)]
--   Just False 
--   
--   &gt;&gt;&gt; evaluate (var 0 `imp` var 1) [(0, True)]
--   Nothing
--   </pre>
evaluate :: Bdd -> Assignment -> Maybe Bool

-- | Evaluates a BDD, given a total assignment function.
--   
--   <pre>
--   &gt;&gt;&gt; evaluateFun (var 0 `imp` var 1) (\ x -&gt; if x == 0 then True else False)
--   False
--   </pre>
evaluateFun :: Bdd -> (Int -> Bool) -> Bool
instance GHC.Read.Read PrintableBdd.Bdd
instance GHC.Classes.Eq PrintableBdd.Bdd
instance GHC.Show.Show PrintableBdd.Bdd


module Util

-- | Prints the given message in a given colour.
putStrFgc :: Color -> String -> IO ()

-- | Prints the given mesage with a new line in a given colour.
putStrLnFgc :: Color -> String -> IO ()

-- | Prints a message that an action is invalid for the current context.
printInvalidAction :: Char -> IO ()

-- | Prints a message that the current graph is complete, i.e. every agent
--   is an expert.
printGraphComplete :: IO ()

-- | Save a Bdd in its graph structure as an SVG file. Uses the dot
--   language, for which Graphviz needs to be installed.
writeToSvgGraph :: String -> Bdd -> IO ()

module GossipTypes

-- | The type of an agent. Agents are always defined in terms of a
--   character and a corresponding (unique) identifying integer.
type Agent = LNode Char

-- | The agent identifier.
type AgentId = Int

-- | The agent name.
type AgentName = Char

-- | A call between two agents, defined as (from<i>caller, to</i>callee). A
--   call is considered to be bidirectional, i.e. information flows from
--   the caller to the callee and vice versa.
type Call = (Agent, Agent)

-- | A call between a group of agents. The first item in the tuple is the
--   caller, they need to have the phone number of all callees in the list.
--   A group call is also omnidirectional, i.e. the all agent information
--   is pooled and distributed to all agents in the call.
type GroupCall = (Agent, [Agent])

-- | Generates a call between two agents.
(☎) :: Agent -> Agent -> Call
infix 0 ☎

-- | Converts a group call to a list of direct calls. This results in an
--   identical flow of information.
toCalls :: GroupCall -> [Call]

-- | Converts an agent to a print-friendly string.
showAgent :: Agent -> String

-- | Prints a call.
printCall :: Call -> IO ()

-- | Prints a list of calls.
printCalls :: [Call] -> IO ()

-- | Prints a message that a call is made between two agents.
printMakeCall :: Call -> IO ()

-- | Prints a group call.
printGroupCall :: GroupCall -> IO ()

-- | Prints a list of group calls.
printGroupCalls :: [GroupCall] -> IO ()

-- | Prints a message that a group call is made.
printMakeGroupCall :: GroupCall -> IO ()

-- | Prints a message that no calls are available.
printNoCalls :: IO ()

-- | Prints all calls, given a list of direct calls and group calls.
printAllCalls :: ([Call], [GroupCall]) -> IO ()


module GossipGraph

-- | The gossip graph. This is defined in terms of the <a>Graph</a> module.
type GossipGraph = Gr AgentName Kind

-- | An agent relation label, indicating whether x knows the number of y,
--   or x knows the secret of y.
data Kind
Number :: Kind
Secret :: Kind

-- | A relation between to agents, either knowledge of number or knowledge
--   of secret.
type Relation = LEdge Kind

-- | Simple graph to be used for testing
testGraph :: GossipGraph

-- | Another simple graph with slightly different number relations.
testGraph2 :: GossipGraph

-- | A slightly bigger graph, with five instead of three agents.
biggerGraph :: GossipGraph

-- | A default graph with generic size. In this graph, every agent only
--   knows their own number.
--   
--   <pre>
--   &gt;&gt;&gt; defaultGraph 3
--   mkGraph [(0,'a'),(1,'b'),(2,'c')] [(0,0,Number),(0,0,Secret),(1,1,Number),(1,1,Secret),(2,2,Number),(2,2,Secret)]
--   </pre>
defaultGraph :: Int -> GossipGraph

-- | Generates an initial gossip graph (with no initial shared secrets),
--   based on a list of agents and their known phone numbers. In this
--   initial graph, everyone will only know their own secret.
--   
--   <pre>
--   &gt;&gt;&gt; initialGraph 2 [('a', "ab"), ('b', "b")]
--   mkGraph [(0,'a'),(1,'b')] [(0,0,Number),(0,0,Secret),(0,1,Number),(1,1,Number),(1,1,Secret)]
--   </pre>
initialGraph :: Int -> [(Char, [Char])] -> GossipGraph

-- | Returns the list of agents of which an agent knows the number, given a
--   gossip graph.
numbersKnownBy :: GossipGraph -> Agent -> [Agent]

-- | Returns the list of agents of which an agent knows the secret, given a
--   gossip graph.
secretsKnownBy :: GossipGraph -> Agent -> [Agent]

-- | Checks whether two agents have some relation, either secret or number.
hasRelationWith :: GossipGraph -> Agent -> Kind -> Agent -> Bool

-- | Check whether each agent is an expert; i.e. knows the secret of
--   everyone.
isGraphComplete :: GossipGraph -> Bool

-- | Returns the amount of agents that are present in a gossip graph.
--   
--   <pre>
--   &gt;&gt;&gt; noAgents testGraph
--   3
--   </pre>
noAgents :: GossipGraph -> Int

-- | Converts an agent ID to an agent label.
--   
--   <pre>
--   &gt;&gt;&gt; idToLab 0
--   'a'
--   
--   &gt;&gt;&gt; idToLab 12
--   'm'
--   </pre>
idToLab :: Int -> Char

-- | Converts an agent label to an agent ID.
--   
--   <pre>
--   &gt;&gt;&gt; labToId 'a'
--   0
--   
--   &gt;&gt;&gt; labToId 'w'
--   22
--   </pre>
labToId :: Char -> Int

-- | Generates an agent, based on its ID.
--   
--   <pre>
--   &gt;&gt;&gt; agentFromId 0
--   (0, 'a')
--   
--   &gt;&gt;&gt; agentFromId 2
--   (2, 'c')
--   </pre>
agentFromId :: Int -> Agent

-- | Generates an agent, based on its label character.
--   
--   <pre>
--   &gt;&gt;&gt; agentFromLab 'a'
--   (0, 'a')
--   
--   &gt;&gt;&gt; agentFromLab 'd'
--   (3, 'd')
--   </pre>
agentFromLab :: Char -> Agent

-- | Generates a relation between to agents, given a relation kind.
relation :: Agent -> Agent -> Kind -> Relation

-- | Prints the graph in a readable manner.
printGraph :: GossipGraph -> IO ()
instance GHC.Show.Show GossipGraph.Kind
instance GHC.Classes.Eq GossipGraph.Kind
instance GHC.Show.Show GossipGraph.LexToken
instance GHC.Classes.Eq GossipGraph.LexToken


module GossipKnowledge

-- | An atomic proposition in a gossip state: Rel(Agent, Agent).
data GossipAtom
GAt :: Rel -> Agent -> Agent -> GossipAtom

-- | The relation type of a GossipAtom.
data Rel

-- | Indicates that x knows the number of y.
N :: Rel

-- | Indicates that x knows the secret of y.
S :: Rel

-- | Indicates that x has called y.
C :: Rel

-- | Converts a BDD variable index to a GossipAtom. Note that the first Int
--   argument corresponds to the amount of agents present in the gossip
--   graph. This is a bijective function to allow for unique indexing of
--   atomic gossip propositions.
--   
--   <pre>
--   &gt;&gt;&gt; intToGAt 3 0
--   Naa
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intToGAt 3 12
--   Sba
--   </pre>
intToGAt :: Int -> Int -> GossipAtom

-- | Converts a BDD formula to a list of GossipAtoms for all variables in
--   the formula. Internally calls intToGAt.
--   
--   <pre>
--   &gt;&gt;&gt; bddToGAt 3 ((var 0) `imp` (var 12))
--   
--   &gt;&gt;&gt; [Naa, Sba]
--   </pre>
bddToGAt :: Int -> Bdd -> [GossipAtom]

-- | Converts a GossipAtom to a unique integer index that can be used for a
--   BDD variable.
--   
--   <pre>
--   &gt;&gt;&gt; gAtToInt 3 (GAt S b a)
--   12
--   </pre>
gAtToInt :: Int -> GossipAtom -> Int

-- | Converts a GossipAtom to a unique but labelled BDD variable. Note that
--   the first argument corresponds to the amount of agents present in the
--   gossip graph.
--   
--   <pre>
--   &gt;&gt;&gt; gAtToBdd 3 (GAt S b a)
--   Sba
--   </pre>
--   
--   Note that, while this function prints the normal gossip atom, the type
--   that is returned is of BDD instead of GossipAtom. Internally, a unique
--   variable index has been generated.
gAtToBdd :: Int -> GossipAtom -> Bdd

-- | Converts an atomic gossip proposition into a LaTeX string.
--   
--   <pre>
--   &gt;&gt;&gt; texify (GAt N a b)
--   \texttt{N}ab
--   </pre>
texifyGAt :: GossipAtom -> String

-- | Converts a BDD variable index to a GossipAtom, and converts that to a
--   LaTeX string.
--   
--   <pre>
--   &gt;&gt;&gt; texifyBddVar 3 12
--   "\texttt{S}ba"
--   </pre>
texifyBddVar :: Int -> Int -> String

-- | An epistemic formula, defined in terms of BDDs. This data structure
--   allows for propositional formulae, as well as (higher-order) agent
--   knowledge.
data Form
Fact :: Bdd -> Form
K :: Agent -> Form -> Form
M :: Agent -> Form -> Form

-- | A recursively defined propositional formula build out of GossipAtoms.
data GossipForm

-- | Always true
Top :: GossipForm

-- | Atom
Atom :: GossipAtom -> GossipForm

-- | Negation
Neg :: GossipForm -> GossipForm

-- | Conjunction
Conj :: [GossipForm] -> GossipForm

-- | Disjunction
Disj :: [GossipForm] -> GossipForm

-- | Implication
Impl :: GossipForm -> GossipForm -> GossipForm

-- | A knowledge structure (Gattinger, 2018) which represents the knowledge
--   of a Gossip State.
data GossipKnowledgeStructure
GKS :: Set Int -> Bdd -> Map Agent (Set Int) -> GossipKnowledgeStructure

-- | The set of propositional atoms available in the model.
vocabulary :: GossipKnowledgeStructure -> Set Int

-- | A boolean formula representing the law that every state needs to
--   adhere to.
stateLaw :: GossipKnowledgeStructure -> Bdd

-- | The set of atoms seen by some agent. If an atom is observable for an
--   agent, then they are certain as to whether this atom is true or false.
observables :: GossipKnowledgeStructure -> Map Agent (Set Int)

-- | Extracts the number of agents from the Knowledge Structure.
nag :: GossipKnowledgeStructure -> Int

-- | Converts a gossip graph to its corresponding knowledge structure. Note
--   that this doesn't convert a gossip state, i.e. no call sequence is
--   encoded. This is meant for the conversion of the _initial_ gossip
--   state, (G, ε) (van Ditmarsch et al., 2017)
fromGossipGraph :: GossipGraph -> GossipKnowledgeStructure

-- | Checks if a given Knowledge Structure is valid. It checks whether the
--   variables found in both the state law and the observable sets are
--   present in the vocabulary.
validKS :: GossipKnowledgeStructure -> Bool

-- | Converts an epistemic formula to a boolean formula, given a knowledge
--   structure in Gattinger (2018), `fromToBdd k ϕ` is denoted by ||ϕ||_k.
formToBdd :: GossipKnowledgeStructure -> Form -> Bdd

-- | An infix operator for the formToBdd function.
(<|>) :: GossipKnowledgeStructure -> Form -> Bdd
infix 9 <|>

-- | The Knowledge Transformer data structure, as defined in (Gattinger,
--   2018).
data KnowledgeTransformer
KT :: Set Int -> Bdd -> Map Agent (Set Int) -> KnowledgeTransformer

-- | Additional vocabulary.
addVocab :: KnowledgeTransformer -> Set Int

-- | The event law.
eventLaw :: KnowledgeTransformer -> Bdd

-- | Additional observables.
addObs :: KnowledgeTransformer -> Map Agent (Set Int)

-- | A base Knowledge Transformer structure, which will not change the
--   Knowledge Structure.
baseTransformer :: KnowledgeTransformer

-- | Checks if a Knowledge Transformer is valid. Checks whether all atoms
--   in the additional vocabulary are actually new, whether the event law
--   only uses variables that are contained in either the original
--   vocabulary or the additional vocabulary, and whether the additional
--   observables are items from the additional vocabulary.
validKT :: GossipKnowledgeStructure -> KnowledgeTransformer -> Bool

-- | Updates a Knowledge Structure, given a Knowledge Transformer.
update :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure

-- | An infix operator for the <a>update</a> function.
(|+|) :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure
infixl 9 |+|

-- | Updates a Knowledge Structure for a given call made between two
--   agents. The integer argument denotes the tick counter.
updateWithCall :: GossipKnowledgeStructure -> Int -> Call -> GossipKnowledgeStructure
instance GHC.Enum.Enum GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.Rel
instance GHC.Classes.Ord GossipKnowledge.Rel
instance GHC.Show.Show GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.GossipAtom
instance GHC.Classes.Ord GossipKnowledge.GossipAtom
instance GHC.Show.Show GossipKnowledge.GossipForm
instance GHC.Classes.Eq GossipKnowledge.GossipKnowledgeStructure
instance GHC.Show.Show GossipKnowledge.GossipKnowledgeStructure
instance GHC.Show.Show GossipKnowledge.Form
instance GHC.Show.Show GossipKnowledge.GossipAtom

module GossipState

-- | The gossip state.
data State
State :: GossipGraph -> GossipKnowledgeStructure -> [Call] -> State

-- | The gossip graph of the current state.
[stateGraph] :: State -> GossipGraph

-- | The knowledge structure of the current state.
[stateKnowledgeStruct] :: State -> GossipKnowledgeStructure

-- | The call sequence of the current state.
[stateCallSeq] :: State -> [Call]

-- | Prints the current state.
printState :: State -> Bool -> IO ()

-- | Determines based on the current GossipGraph state which calls are
--   actually allowed to be made. Note that no protocols are used for this,
--   a call between a and b is valid iff a knows the number of b.
validCalls :: GossipGraph -> ([Call], [GroupCall])

-- | Makes a call and update the state.
makeCall :: Call -> State -> State

-- | Makes multiple calls by repeatedly invoking <a>makeCall</a>.
executeCalls :: [Call] -> State -> IO State

-- | Evaluates a gossip atom (N(x,y), S(x,y) or C(x,y)), given the current
--   state
evaluateGossipAtom :: State -> GossipAtom -> Bool

-- | Evaluates a Bdd variable as Int, given the current state
evaluateBddVar :: State -> Int -> Bool

-- | Evaluates an epistemic formula, given the current state
evaluate :: State -> Form -> Bool

-- | An infix operator of the <a>evaluate</a> function.
(|=) :: State -> Form -> Bool
infix 9 |=

-- | Legacy method, evalute a GossipFormula (note, without knowledge) by
--   naive recursion
evaluate' :: State -> GossipForm -> Bool


module GossipProtocol

-- | A protocol for dynamic gossip. Following (van Ditmarsch et al., 2017),
--   a gossip protocol is defined as an epistemic formula using two agents.
--   If this formula resolves to true, a call between these agents is
--   allowed. If the formula resolves to false, such a call is not allowed.
--   The first argument denotes the amount of agents, the second argument
--   is the current knowledge structure, whereas the third argument denotes
--   the call in question.
type GossipProtocol = Int -> GossipKnowledgeStructure -> Call -> Form

-- | Converts a protocol to a string notation, as used in (van Ditmarsch et
--   al., 2017).
showProtocol :: State -> GossipProtocol -> String

-- | The most simple and naive protocol, it allows any call to be made.
--   φ(a,b) = ⊤
callAny :: GossipProtocol

-- | This protocol only allows a call if it leads to new secrets to be
--   learned. φ(a,b) = ¬S(a,b)
learnNewSecrets :: GossipProtocol

-- | Introduced by (van Ditmarsch et al., 2017): "Call xy can be made if x
--   knows y's number and if x considers it possible that there is a secret
--   known by one of x,y but not the other." φ(a,b) = ⋁_{z ∈ A}( S(x, z) ↔︎
--   ¬S(y, z) )
possibleInformationGrowth :: GossipProtocol

-- | Selects all calls that are allowed by the given gossip protocol. Note
--   that there could also be no calls allowed.
selectedCalls :: GossipProtocol -> State -> ([Call], [GroupCall])


module Program

-- | Main entry point to the program.
runProgram :: IO ()
