-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/RamonMeffert/epistemic-group-gossip#readme</a>
@package epistemic-group-gossip
@version 0.1.0.0


module PrintableBdd

-- | Printable data wrapper for the <a>Bdd</a> record.
data Bdd

-- | The binary decision diagram, as a <a>Bdd</a> type.
bdd :: Bdd -> Bdd

-- | The formula represented as a unicode string for direct printing.
str :: Bdd -> String

-- | The formula represented as a string, formatted in LaTeX.
tex :: Bdd -> String

-- | An assignment is a valuation for a set of variables, i.e. a valuation
--   as to whether a variable is true or false.
type Assignment = [(Int, Bool)]

-- | The printable BDD can label their variables, instead of using
--   integers. A VarLabeller type is a function that encodes a variable
--   integer to its corresponding name.
type VarLabeller = (Int -> String)

-- | Encode a labelled integer as a BDD variable. Note that the first
--   labeller is for text, the second for LaTeX. The variable is indexed by
--   any integer from 0 to 1.000.000.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = varl slabel tlabel 0
--   
--   &gt;&gt;&gt; foo
--   var0
--   
--   &gt;&gt;&gt; tex foo
--   p_0
--   </pre>
varl :: VarLabeller -> VarLabeller -> Int -> Bdd

-- | Encode an unlabelled integer as a BDD variable. The variable is
--   indexed by any integer from 0 to 1.000.000.
var :: Int -> Bdd

-- | True constant.
--   
--   <pre>
--   &gt;&gt;&gt; top
--   ⊤
--   </pre>
top :: Bdd

-- | False constant.
--   
--   <pre>
--   &gt;&gt;&gt; bot
--   ⊥
--   </pre>
bot :: Bdd

-- | Negation.
--   
--   <pre>
--   &gt;&gt;&gt; neg foo
--   ¬(foo)
--   </pre>
neg :: Bdd -> Bdd

-- | Conjunction.
--   
--   <pre>
--   &gt;&gt;&gt; foo `con` bar
--   (foo ∧ bar)
--   </pre>
con :: Bdd -> Bdd -> Bdd

-- | Disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; foo `dis` bar
--   (foo ∨ bar)
--   </pre>
dis :: Bdd -> Bdd -> Bdd

-- | Logical implication.
--   
--   <pre>
--   &gt;&gt;&gt; foo `imp` bar
--   (foo ⟶ bar)
--   </pre>
imp :: Bdd -> Bdd -> Bdd

-- | Logical bi-implication or equivalence.
--   
--   <pre>
--   &gt;&gt;&gt; foo `equ` bar
--   (foo ⟷ bar)
--   </pre>
equ :: Bdd -> Bdd -> Bdd

-- | Exlusive or.
--   
--   <pre>
--   &gt;&gt;&gt; foo `xor` bar
--   (foo ⊻ bar)
--   </pre>
xor :: Bdd -> Bdd -> Bdd

-- | Big (setwise) conjunction.
--   
--   <pre>
--   &gt;&gt;&gt; conSet [foo, bar, baz]
--   (foo ∧ bar ∧ baz)
--   </pre>
conSet :: [Bdd] -> Bdd

-- | Big (setwise) disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; disSet [foo, bar, baz]
--   (foo ∨ bar ∨ baz)
--   </pre>
disSet :: [Bdd] -> Bdd

-- | Big (setwise) exclusive disjunction.
--   
--   <pre>
--   &gt;&gt;&gt; xorSet [foo, bar, baz]
--   (foo ⊻ bar ⊻ baz)
--   </pre>
xorSet :: [Bdd] -> Bdd

-- | Labelled binary universal quantification. Note that the first
--   VarLabeller works for direct printing and the VarLabeller is for
--   latex.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = foralll slabel tlabel 0 $ varl slabel tlabel 0 `imp` varl slabel tlabel 1
--   
--   &gt;&gt;&gt; foo
--   ∀var0(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\forall p_0 (p_0 \\rightarrow p_1)
--   </pre>
foralll :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd

-- | Unlabelled binary universal quantification.
--   
--   <pre>
--   &gt;&gt;&gt; forall 0 foo
--   ∀0(foo)
--   </pre>
forall :: Int -> Bdd -> Bdd

-- | Labelled binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = existsl slabel tlabel 0 $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∃var0(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\exists (p_0 \\rightarrow p_1) 
--   </pre>
existsl :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd

-- | Unlabelled binary existential quantification
--   
--   <pre>
--   &gt;&gt;&gt; exists 0 foo
--   ∃0(foo)
--   </pre>
exists :: Int -> Bdd -> Bdd

-- | Labelled big binary universal quanficition.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = forallSetl slabel tlabel [0, 1] $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∀{var0, var1}(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\forall \\left{ p_0, p_1 \\right} (p_0 \\rightarrow p_1)
--   </pre>
forallSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd

-- | Unlabelled big binary universal quantification.
--   
--   <pre>
--   &gt;&gt;&gt; forallSet [0,1,2] foo
--   ∀{0,1,2}(foo)
--   </pre>
forallSet :: [Int] -> Bdd -> Bdd

-- | Labelled big binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; slabel n = "var" ++ (show n)
--   
--   &gt;&gt;&gt; tlabel n = "p_" ++ (show n)
--   
--   &gt;&gt;&gt; foo = existsSetl slabel tlabel [0, 1] $ (varl slabel tlabel 0) `imp` (varl slabel tlabel 1)
--   
--   &gt;&gt;&gt; foo
--   ∃{var0, var1}(var0 ⟶ var1)
--   
--   &gt;&gt;&gt; tex foo
--   \\exists \\left{ p_0, p_1 \\right} (p_0 \\rightarrow p_1)
--   </pre>
existsSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd

-- | Unlabelled big binary existential quantification.
--   
--   <pre>
--   &gt;&gt;&gt; existsSet [0,1,2] foo
--   ∃{0,1,2}(foo)
--   </pre>
existsSet :: [Int] -> Bdd -> Bdd

-- | Labelled substitution.
--   
--   <pre>
--   &gt;&gt;&gt; label n = "var" ++ n
--   
--   &gt;&gt;&gt; subsitl label 0 top foo
--   [var0\⊤](foo)
--   </pre>
substitl :: VarLabeller -> Int -> Bdd -> Bdd -> Bdd

-- | Unlabelled substitution.
--   
--   <pre>
--   &gt;&gt;&gt; substit 0 top foo
--   [0\⊤]foo
--   </pre>
substit :: Int -> Bdd -> Bdd -> Bdd

-- | Returns all variables (without labels) that occur within the given
--   BDD.
--   
--   <pre>
--   &gt;&gt;&gt; allVarsOf (var 0 `imp` (var 1 `dis` var 2))
--   [0,1,2]
--   </pre>
allVarsOf :: Bdd -> [Int]

-- | Evaluate a BDD, given an assignment. Returns Nothing if the assignment
--   doesn't contain all variables of the BDD.
--   
--   <pre>
--   &gt;&gt;&gt; evaluate (var 0 `imp` var 1) [(0, True), (1, False)]
--   Just False 
--   
--   &gt;&gt;&gt; evaluate (var 0 `imp` var 1) [(0, True)]
--   Nothing
--   </pre>
evaluate :: Bdd -> Assignment -> Maybe Bool

-- | Evaluates a BDD, given a total assignment function.
--   
--   <pre>
--   &gt;&gt;&gt; evaluateFun (var 0 `imp` var 1) (\ x -&gt; if x == 0 then True else False)
--   False
--   </pre>
evaluateFun :: Bdd -> (Int -> Bool) -> Bool
instance GHC.Read.Read PrintableBdd.Bdd
instance GHC.Classes.Eq PrintableBdd.Bdd
instance GHC.Show.Show PrintableBdd.Bdd

module ToDo
getToDo :: IO ()

module Util
printInvalidActionStr :: String -> IO ()
printInvalidAction :: Char -> IO ()
printGraphComplete :: IO ()
putStrFgc :: Color -> String -> IO ()
putStrLnFgc :: Color -> String -> IO ()
writeGraph :: String -> Bdd -> IO ()

module GossipTypes
type Agent = LNode Char
type AgentId = Int
type AgentName = Char

-- | (from, to). Call is considered to be bidirectional, Optionally we
--   could add a direction component to allow singe directional
--   broadcasting calls.
type Call = (Agent, Agent)
type GroupCall = (Agent, [Agent])
(☎) :: Agent -> Agent -> Call
infix 0 ☎
toCalls :: GroupCall -> [Call]
showAgent :: Agent -> String
printNoCalls :: IO ()
printCall :: Call -> IO ()
printMakeCall :: Call -> IO ()
printCalls :: [Call] -> IO ()
printGroupCall :: GroupCall -> IO ()
printMakeGroupCall :: GroupCall -> IO ()
printGroupCalls :: [GroupCall] -> IO ()
printAllCalls :: ([Call], [GroupCall]) -> IO ()


module GossipGraph

-- | The gossip graph. This is defined in terms of the <a>Graph</a> module.
type GossipGraph = Gr AgentName Kind

-- | An agent relation label, indicating whether x knows the number of y,
--   or x knows the secret of y.
data Kind
Number :: Kind
Secret :: Kind

-- | A relation between to agents, either knowledge of number or knowledge
--   of secret.
type Relation = LEdge Kind

-- | Simple graph to be used for testing
testGraph :: GossipGraph

-- | Another simple graph with slightly different number relations.
testGraph2 :: GossipGraph

-- | A slightly bigger graph, with five instead of three agents.
biggerGraph :: GossipGraph

-- | A default graph with generic size. In this graph, every agent only
--   knows their own number.
--   
--   <pre>
--   &gt;&gt;&gt; defaultGraph 3
--   mkGraph [(0,'a'),(1,'b'),(2,'c')] [(0,0,Number),(0,0,Secret),(1,1,Number),(1,1,Secret),(2,2,Number),(2,2,Secret)]
--   </pre>
defaultGraph :: Int -> GossipGraph

-- | Generates an initial gossip graph (with no initial shared secrets),
--   based on a list of agents and their known phone numbers. In this
--   initial graph, everyone will only know their own secret.
--   
--   <pre>
--   &gt;&gt;&gt; initialGraph 2 [('a', "ab"), ('b', "b")]
--   mkGraph [(0,'a'),(1,'b')] [(0,0,Number),(0,0,Secret),(0,1,Number),(1,1,Number),(1,1,Secret)]
--   </pre>
initialGraph :: Int -> [(Char, [Char])] -> GossipGraph

-- | Returns the list of agents of which an agent knows the number, given a
--   gossip graph.
numbersKnownBy :: GossipGraph -> Agent -> [Agent]

-- | Returns the list of agents of which an agent knows the secret, given a
--   gossip graph.
secretsKnownBy :: GossipGraph -> Agent -> [Agent]

-- | Checks whether two agents have some relation, either secret or number.
hasRelationWith :: GossipGraph -> Agent -> Kind -> Agent -> Bool

-- | Check whether each agent is an expert; i.e. knows the secret of
--   everyone.
isGraphComplete :: GossipGraph -> Bool

-- | Returns the amount of agents that are present in a gossip graph.
--   
--   <pre>
--   &gt;&gt;&gt; noAgents testGraph
--   3
--   </pre>
noAgents :: GossipGraph -> Int

-- | Converts an agent ID to an agent label.
--   
--   <pre>
--   &gt;&gt;&gt; idToLab 0
--   'a'
--   
--   &gt;&gt;&gt; idToLab 12
--   'm'
--   </pre>
idToLab :: Int -> Char

-- | Converts an agent label to an agent ID.
--   
--   <pre>
--   &gt;&gt;&gt; labToId 'a'
--   0
--   
--   &gt;&gt;&gt; labToId 'w'
--   22
--   </pre>
labToId :: Char -> Int

-- | Generates an agent, based on its ID.
--   
--   <pre>
--   &gt;&gt;&gt; agentFromId 0
--   (0, 'a')
--   
--   &gt;&gt;&gt; agentFromId 2
--   (2, 'c')
--   </pre>
agentFromId :: Int -> Agent

-- | Generates an agent, based on its label character.
--   
--   <pre>
--   &gt;&gt;&gt; agentFromLab 'a'
--   (0, 'a')
--   
--   &gt;&gt;&gt; agentFromLab 'd'
--   (3, 'd')
--   </pre>
agentFromLab :: Char -> Agent

-- | Generates a relation between to agents, given a relation kind.
relation :: Agent -> Agent -> Kind -> Relation

-- | Prints the graph in a readable manner.
printGraph :: GossipGraph -> IO ()
instance GHC.Show.Show GossipGraph.Kind
instance GHC.Classes.Eq GossipGraph.Kind
instance GHC.Show.Show GossipGraph.LexToken
instance GHC.Classes.Eq GossipGraph.LexToken


module GossipKnowledge

-- | An atomic proposition in a gossip state: Rel(Agent, Agent).
data GossipAtom
GAt :: Rel -> Agent -> Agent -> GossipAtom

-- | The relation type of a GossipAtom.
data Rel

-- | Indicates that x knows the number of y.
N :: Rel

-- | Indicates that x knows the secret of y.
S :: Rel

-- | Indicates that x has called y.
C :: Rel

-- | Converts a BDD variable index to a GossipAtom. Note that the first Int
--   argument corresponds to the amount of agents present in the gossip
--   graph. This is a bijective function to allow for unique indexing of
--   atomic gossip propositions.
--   
--   <pre>
--   &gt;&gt;&gt; intToGAt 3 0
--   Naa
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intToGAt 3 12
--   Sba
--   </pre>
intToGAt :: Int -> Int -> GossipAtom

-- | Converts a BDD formula to a list of GossipAtoms for all variables in
--   the formula. Internally calls intToGAt.
--   
--   <pre>
--   &gt;&gt;&gt; bddToGAt 3 ((var 0) `imp` (var 12))
--   
--   &gt;&gt;&gt; [Naa, Sba]
--   </pre>
bddToGAt :: Int -> Bdd -> [GossipAtom]

-- | Converts a GossipAtom to a unique integer index that can be used for a
--   BDD variable.
--   
--   <pre>
--   &gt;&gt;&gt; gAtToInt 3 (GAt S b a)
--   12
--   </pre>
gAtToInt :: Int -> GossipAtom -> Int

-- | Converts a GossipAtom to a unique but labelled BDD variable. Note that
--   the first argument corresponds to the amount of agents present in the
--   gossip graph.
--   
--   <pre>
--   &gt;&gt;&gt; gAtToBdd 3 (GAt S b a)
--   Sba
--   </pre>
--   
--   Note that, while this function prints the normal gossip atom, the type
--   that is returned is of BDD instead of GossipAtom. Internally, a unique
--   variable index has been generated.
gAtToBdd :: Int -> GossipAtom -> Bdd

-- | Converts an atomic gossip proposition into a LaTeX string.
--   
--   <pre>
--   &gt;&gt;&gt; texify (GAt N a b)
--   \texttt{N}ab
--   </pre>
texifyGAt :: GossipAtom -> String

-- | Converts a BDD variable index to a GossipAtom, and converts that to a
--   LaTeX string.
--   
--   <pre>
--   &gt;&gt;&gt; texifyBddVar 3 12
--   "\texttt{S}ba"
--   </pre>
texifyBddVar :: Int -> Int -> String

-- | An epistemic formula, defined in terms of BDDs. This data structure
--   allows for propositional formulae, as well as (higher-order) agent
--   knowledge.
data Form
Fact :: Bdd -> Form
K :: Agent -> Form -> Form
M :: Agent -> Form -> Form

-- | A recursively defined propositional formula build out of GossipAtoms.
data GossipForm

-- | Always true
Top :: GossipForm

-- | Atom
Atom :: GossipAtom -> GossipForm

-- | Negation
Neg :: GossipForm -> GossipForm

-- | Conjunction
Conj :: [GossipForm] -> GossipForm

-- | Disjunction
Disj :: [GossipForm] -> GossipForm

-- | Implication
Impl :: GossipForm -> GossipForm -> GossipForm

-- | A knowledge structure (Gattinger, 2018) which represents the knowledge
--   of a Gossip State.
data GossipKnowledgeStructure
GKS :: Set Int -> Bdd -> Map Agent (Set Int) -> GossipKnowledgeStructure

-- | The set of propositional atoms available in the model.
vocabulary :: GossipKnowledgeStructure -> Set Int

-- | A boolean formula representing the law that every state needs to
--   adhere to.
stateLaw :: GossipKnowledgeStructure -> Bdd

-- | The set of atoms seen by some agent. If an atom is observable for an
--   agent, then they are certain as to whether this atom is true or false.
observables :: GossipKnowledgeStructure -> Map Agent (Set Int)

-- | Converts a gossip graph to its corresponding knowledge structure. Note
--   that this doesn't convert a gossip state, i.e. no call sequence is
--   encoded. This is meant for the conversion of the _initial_ gossip
--   state, (G, ε) (van Ditmarsch et al., 2017)
fromGossipGraph :: GossipGraph -> GossipKnowledgeStructure

-- | Checks if a given Knowledge Structure is valid. It checks whether the
--   variables found in both the state law and the observable sets are
--   present in the vocabulary.
validKS :: GossipKnowledgeStructure -> Bool

-- | Converts an epistemic formula to a boolean formula, given a knowledge
--   structure in Gattinger (2018), `fromToBdd k ϕ` is denoted by ||ϕ||_k.
formToBdd :: GossipKnowledgeStructure -> Form -> Bdd

-- | An infix operator for the formToBdd function.
(<|>) :: GossipKnowledgeStructure -> Form -> Bdd
infix 9 <|>

-- | The Knowledge Transformer data structure, as defined in (Gattinger,
--   2018).
data KnowledgeTransformer
KT :: Set Int -> Bdd -> Map Agent (Set Int) -> KnowledgeTransformer

-- | Additional vocabulary.
addVocab :: KnowledgeTransformer -> Set Int

-- | The event law.
eventLaw :: KnowledgeTransformer -> Bdd

-- | Additional observables.
addObs :: KnowledgeTransformer -> Map Agent (Set Int)

-- | A base Knowledge Transformer structure, which will not change the
--   Knowledge Structure.
baseTransformer :: KnowledgeTransformer

-- | Checks if a Knowledge Transformer is valid. Checks whether all atoms
--   in the additional vocabulary are actually new, whether the event law
--   only uses variables that are contained in either the original
--   vocabulary or the additional vocabulary, and whether the additional
--   observables are items from the additional vocabulary.
validKT :: GossipKnowledgeStructure -> KnowledgeTransformer -> Bool

-- | Updates a Knowledge Structure, given a Knowledge Transformer.
update :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure

-- | An infix operator for the <a>update</a> function.
(|+|) :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure
infixl 9 |+|

-- | Updates a Knowledge Structure for a given call made between two
--   agents. The integer argument denotes the tick counter.
updateWithCall :: GossipKnowledgeStructure -> Int -> Call -> GossipKnowledgeStructure
instance GHC.Enum.Enum GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.Rel
instance GHC.Classes.Ord GossipKnowledge.Rel
instance GHC.Show.Show GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.GossipAtom
instance GHC.Classes.Ord GossipKnowledge.GossipAtom
instance GHC.Show.Show GossipKnowledge.GossipForm
instance GHC.Classes.Eq GossipKnowledge.GossipKnowledgeStructure
instance GHC.Show.Show GossipKnowledge.GossipKnowledgeStructure
instance GHC.Show.Show GossipKnowledge.Form
instance GHC.Show.Show GossipKnowledge.GossipAtom

module GossipState
data State
State :: GossipGraph -> GossipKnowledgeStructure -> [Call] -> State
[stateGraph] :: State -> GossipGraph
[stateKnowledgeStruct] :: State -> GossipKnowledgeStructure
[stateCallSeq] :: State -> [Call]
printState :: State -> Bool -> IO ()

-- | Determines based on the current GossipGraph state which calls are
--   actually allowed to be made.
validCalls :: GossipGraph -> ([Call], [GroupCall])
executeCalls :: [Call] -> State -> IO State
makeCall :: Call -> State -> State

-- | Evaluates a gossip atom (N(x,y), S(x,y) or C(x,y)), given the current
--   state
evaluateGossipAtom :: State -> GossipAtom -> Bool

-- | Evaluates a Bdd variable as Int, given the current state
evaluateBddVar :: State -> Int -> Bool

-- | Evaluates an epistemic formula, given the current state
evaluate :: State -> Form -> Bool

-- | An infix operator of the <a>evaluate</a> function.
(|=) :: State -> Form -> Bool
infix 9 |=

-- | Legacy method, evalute a GossipFormula (note, without knowledge) by
--   naive recursion
evaluate' :: State -> GossipForm -> Bool
tester :: Int -> Bool

module GossipProtocol

-- | Placeholder (definitely needs updating!)
type GossipProtocol = Int -> GossipKnowledgeStructure -> Call -> Form
callAny :: GossipProtocol
learnNewSecrets :: GossipProtocol
possibleInformationGrowth :: GossipProtocol

-- | Chooses the <tt>best</tt> call using the rules stated in the protocol
--   and the allowed calls. This might also be no call, hence Maybe.
selectedCalls :: GossipProtocol -> State -> ([Call], [GroupCall])

module Program

-- | Main entry point to the program. Parses the gossipgraph and allows
--   user to select what
runProgram :: IO ()
