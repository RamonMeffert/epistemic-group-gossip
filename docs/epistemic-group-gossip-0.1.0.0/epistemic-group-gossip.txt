-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/RamonMeffert/epistemic-group-gossip#readme</a>
@package epistemic-group-gossip
@version 0.1.0.0

module GossipTypes
type Agent = LNode Char
type AgentId = Int
type AgentName = Char

-- | (from, to). Call is considered to be bidirectional, Optionally we
--   could add a direction component to allow singe directional
--   broadcasting calls.
type Call = (Agent, Agent)
showAgent :: Agent -> String
printCall :: Call -> IO ()
printMakeCall :: Call -> IO ()
printCalls :: [Call] -> IO ()

module GossipGraph

-- | Edge label indicating whether an agent knows the number or secret of
--   another agent
data Kind
Number :: Kind
Secret :: Kind
type Relation = LEdge Kind
type GossipGraph = Gr AgentName Kind
printGraph :: GossipGraph -> IO ()

-- | Simple graph to be used for testing
testGraph :: GossipGraph
testGraph2 :: GossipGraph
biggerGraph :: GossipGraph
defaultGraph :: Int -> GossipGraph

-- | Generate an initial gossip graph (with no initial shared secrets),
--   based on a list of agents and their known phone numbers.
initialGraph :: Int -> [(Char, [Char])] -> GossipGraph

-- | Convert an agent ID to an agent label
idToLab :: Int -> Char

-- | Convert an agent label to an agnet ID
labToId :: Char -> Int
hasRelationWith :: GossipGraph -> Agent -> Kind -> Agent -> Bool
numbersKnownBy :: GossipGraph -> Agent -> [Agent]
secretsKnownBy :: GossipGraph -> Agent -> [Agent]
noAgents :: GossipGraph -> Int

-- | Warning, ignores the Char argument! Remains for legacy purposes.
agent :: Int -> Char -> Agent
agentFromId :: Int -> Agent
agentFromLab :: Char -> Agent
relation :: Agent -> Agent -> Kind -> Relation

-- | Given a list of agents and a name, try to find a matching agent
findAgentByName :: [Agent] -> AgentName -> Maybe Agent

-- | Check whether each agent is an expert; i.e. knows the secret of
--   everyone.
graphIsComplete :: GossipGraph -> Bool

-- | Possible tokens in the input string
data LexToken
Token :: Kind -> AgentName -> AgentId -> LexToken
Separator :: LexToken

-- | Lexing for gossip graph input
lexer :: String -> Maybe [LexToken]

-- | Extract the agents from the lexed input string
parseAgents :: [LexToken] -> Maybe [Agent]

-- | Extract the relations from the parsed agents and the lexed input
--   string
parseRelations :: [Agent] -> [LexToken] -> Maybe [Relation]

-- | Try to parse a string representation of a gossip graph into a gossip
--   graph
fromString :: String -> Maybe (Gr AgentName Kind)

-- | Given a set of agents and corresponding relations, construct a gossip
--   graph
fromAgentsAndRelations :: [Agent] -> [Relation] -> Gr AgentName Kind

-- | Debugging function to check if parsing was successful
toStringIfSuccessful :: Maybe (Gr Agent Relation) -> String
instance GHC.Show.Show GossipGraph.Kind
instance GHC.Classes.Eq GossipGraph.Kind
instance GHC.Show.Show GossipGraph.LexToken
instance GHC.Classes.Eq GossipGraph.LexToken

module PrintableBdd
data Bdd
type VarLabeller = (Int -> String)
varl :: VarLabeller -> VarLabeller -> Int -> Bdd
var :: Int -> Bdd
top :: Bdd
bot :: Bdd
neg :: Bdd -> Bdd
con :: Bdd -> Bdd -> Bdd
dis :: Bdd -> Bdd -> Bdd
imp :: Bdd -> Bdd -> Bdd
equ :: Bdd -> Bdd -> Bdd
xor :: Bdd -> Bdd -> Bdd
foralll :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd
forall :: Int -> Bdd -> Bdd
existsl :: VarLabeller -> VarLabeller -> Int -> Bdd -> Bdd
exists :: Int -> Bdd -> Bdd
forallSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd
forallSet :: [Int] -> Bdd -> Bdd
existsSetl :: VarLabeller -> VarLabeller -> [Int] -> Bdd -> Bdd
existsSet :: [Int] -> Bdd -> Bdd
conSet :: [Bdd] -> Bdd
disSet :: [Bdd] -> Bdd
xorSet :: [Bdd] -> Bdd
allVarsOf :: Bdd -> [Int]
evaluate :: Bdd -> Assignment -> Maybe Bool
evaluateFun :: Bdd -> (Int -> Bool) -> Bool
instance GHC.Read.Read PrintableBdd.Bdd
instance GHC.Classes.Eq PrintableBdd.Bdd
instance GHC.Show.Show PrintableBdd.Bdd

module ToDo
getToDo :: IO ()

module Util
printInvalidActionStr :: String -> IO ()
printInvalidAction :: Char -> IO ()
printGraphComplete :: IO ()
putStrFgc :: Color -> String -> IO ()
putStrLnFgc :: Color -> String -> IO ()
writeGraph :: String -> Bdd -> IO ()

module GossipKnowledge

-- | The relation type of a GossipAtom.
data Rel

-- | x knows the number of y
N :: Rel

-- | x knows the secret of y
S :: Rel

-- | x has called y
C :: Rel

-- | An atomic proposition in a gossip state: Rel(Agent, Agent)
data GossipAtom
GAt :: Rel -> Agent -> Agent -> GossipAtom
texify :: GossipAtom -> String

-- | Converts Bdd formula to a list of GossipAtoms for all variables in the
--   formula
bddToGAt :: Int -> Bdd -> [GossipAtom]

-- | Converts a Bbd variable index to a GossipAtom
varToGAt :: Int -> Int -> GossipAtom

-- | Convert a bdd variable index to a GossipAtom string
showBddVar :: Int -> Int -> String
texifyBddVar :: Int -> Int -> String
strLabel :: Int -> VarLabeller
texLabel :: Int -> VarLabeller
gvar :: Int -> Int -> Bdd

-- | Convert a GossipAtom to a Bdd variable
gAtToBdd :: Int -> GossipAtom -> Bdd

-- | Convert a GossipAtom to a unique integer
gAtToInt :: Int -> GossipAtom -> Int

-- | A formula build o' of GossipAtoms, using the language of (van
--   Ditmarsch et al., 2017). We're not certain we need this, we might
--   fully stick with Bdd formulae instead.
data GossipForm

-- | Always true
Top :: GossipForm

-- | Atom
Atom :: GossipAtom -> GossipForm

-- | Negation
Neg :: GossipForm -> GossipForm

-- | Conjunction
Conj :: [GossipForm] -> GossipForm

-- | Disjunction
Disj :: [GossipForm] -> GossipForm

-- | Implication
Impl :: GossipForm -> GossipForm -> GossipForm

-- | An epistemic formula, defined in terms of Bdd's
data Form
Fact :: Bdd -> Form
K :: Agent -> Form -> Form

-- | A knowledge structure (Gattinger, 2018) which represents the knowledge
--   of a Gossip State
data GossipKnowledgeStructure
GKS :: Set Int -> Bdd -> Map Agent (Set Int) -> GossipKnowledgeStructure

-- | The set of atoms available in the model
[vocabulary] :: GossipKnowledgeStructure -> Set Int

-- | A boolean formula representing the law that every state needs to
--   adhere to
[stateLaw] :: GossipKnowledgeStructure -> Bdd

-- | The set of atoms seen by some agent
[observables] :: GossipKnowledgeStructure -> Map Agent (Set Int)
nag :: GossipKnowledgeStructure -> Int
validKS :: GossipKnowledgeStructure -> Bool
gforall :: GossipKnowledgeStructure -> Int -> Bdd -> Bdd
gexists :: GossipKnowledgeStructure -> Int -> Bdd -> Bdd
gforallSet :: GossipKnowledgeStructure -> [Int] -> Bdd -> Bdd
gexistsSet :: GossipKnowledgeStructure -> [Int] -> Bdd -> Bdd

-- | Converts a gossip graph to its corresponding knowledge structure. Note
--   that this doesn't convert a gossip state, i.e. no call sequence is
--   encoded. This is meant for the conversion of the _initial_ gossip
--   state, (G, ε) (van Ditmarsch et al., 2017)
fromGossipGraph :: GossipGraph -> GossipKnowledgeStructure

-- | Convert an epistemic formula to a boolean formula, given a knowledge
--   structure in Gattinger (2018), this is denoted by ||ϕ||_F
formToBdd :: GossipKnowledgeStructure -> Form -> Bdd
(<|>) :: GossipKnowledgeStructure -> Form -> Bdd
infix 9 <|>
data KnowledgeTransformer
KT :: Set Int -> Bdd -> Map Agent (Set Int) -> KnowledgeTransformer

-- | Additional vocabulary
[addVocab] :: KnowledgeTransformer -> Set Int

-- | Event law
[eventLaw] :: KnowledgeTransformer -> Bdd

-- | Additional observables
[addObs] :: KnowledgeTransformer -> Map Agent (Set Int)
baseTransformer :: KnowledgeTransformer
validKT :: GossipKnowledgeStructure -> KnowledgeTransformer -> Bool
update :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure
(|+|) :: GossipKnowledgeStructure -> KnowledgeTransformer -> GossipKnowledgeStructure
infixl 9 |+|
synchronousUpdate :: GossipKnowledgeStructure -> Int -> Call -> GossipKnowledgeStructure
instance GHC.Enum.Enum GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.Rel
instance GHC.Classes.Ord GossipKnowledge.Rel
instance GHC.Show.Show GossipKnowledge.Rel
instance GHC.Classes.Eq GossipKnowledge.GossipAtom
instance GHC.Classes.Ord GossipKnowledge.GossipAtom
instance GHC.Show.Show GossipKnowledge.GossipForm
instance GHC.Show.Show GossipKnowledge.GossipKnowledgeStructure
instance GHC.Show.Show GossipKnowledge.Form
instance GHC.Show.Show GossipKnowledge.GossipAtom

module GossipState
data State
State :: GossipGraph -> GossipKnowledgeStructure -> [Call] -> State
[stateGraph] :: State -> GossipGraph
[stateKnowledgeStruct] :: State -> GossipKnowledgeStructure
[stateCallSeq] :: State -> [Call]
printState :: State -> Bool -> IO ()

-- | Determines based on the current GossipGraph state which calls are
--   actually allowed to be made.
validCalls :: GossipGraph -> [Call]
makeCall :: Call -> State -> State

-- | Evaluate a gossip atom (N(x,y), S(x,y) or C(x,y)), given the current
--   state
evaluateGossipAtom :: State -> GossipAtom -> Bool

-- | Evaluate a Bdd variable as Int, given the current state
evaluateBddVar :: State -> Int -> Bool

-- | Evaluate an epistemic formula, given the current state
evaluate :: State -> Form -> Bool

-- | Evaluate a formula, given the current state
(|=) :: State -> Form -> Bool
infix 9 |=

-- | Legacy method, evalute a GossipFormula (note, without knowledge) by
--   naive recursion
evaluate' :: State -> GossipForm -> Bool

module GossipProtocol

-- | Placeholder (definitely needs updating!)
type GossipProtocol = Int -> Call -> Form
callAny :: GossipProtocol
learnNewSecrets :: GossipProtocol

-- | Chooses the <tt>best</tt> call using the rules stated in the protocol
--   and the allowed calls. This might also be no call, hence Maybe.
selectedCalls :: GossipProtocol -> State -> [Call]

module Program

-- | Main entry point to the program. Parses the gossipgraph and allows
--   user to select what
runProgram :: IO ()
